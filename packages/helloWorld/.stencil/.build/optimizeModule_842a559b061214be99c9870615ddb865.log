const e="hello-world";const t={hydratedSelectorName:"hydrated"};var n=Object.defineProperty;var r=(e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:true})};var o=e=>{if(e.__stencil__getHostRef){return e.__stencil__getHostRef()}return void 0};var s=(e,t)=>{e.__stencil__getHostRef=()=>t;t.t=e};var i=(e,t)=>{const n={o:0,$hostElement$:e,i:t,l:new Map};{n.u=new Promise((e=>n.v=e));e["s-p"]=[];e["s-rc"]=[]}const r=n;e.__stencil__getHostRef=()=>r;return r};var l=(e,t)=>(0,console.error)(e,t);var a=new Map;var c=(e,t,n)=>{const r=e.p.replace(/-/g,"_");const o=e.h;if(!o){return void 0}const s=a.get(o);if(s){return s[r]}
/*!__STENCIL_STATIC_IMPORT_SWITCH__*/return import(`./${o}.entry.js${""}`).then((e=>{{a.set(o,e)}return e[r]}),(e=>{l(e,t.$hostElement$)}))};var f=new Map;var u="{visibility:hidden}.hydrated{visibility:inherit}";var v="slot-fb{display:contents}slot-fb[hidden]{display:none}";var d=typeof window!=="undefined"?window:{};var p={o:0,m:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,n,r)=>e.addEventListener(t,n,r),rel:(e,t,n,r)=>e.removeEventListener(t,n,r),ce:(e,t)=>new CustomEvent(e,t)};var h=e=>Promise.resolve(e);var m=(()=>{try{new CSSStyleSheet;return typeof(new CSSStyleSheet).replaceSync==="function"}catch(e){}return false})();var y=m?(()=>!!d.document&&Object.getOwnPropertyDescriptor(d.document.adoptedStyleSheets,"length").writable)():false;var w=false;var $=[];var b=[];var S=(e,t)=>n=>{e.push(n);if(!w){w=true;if(t&&p.o&4){j(k)}else{p.raf(k)}}};var g=e=>{for(let t=0;t<e.length;t++){try{e[t](performance.now())}catch(e){l(e)}}e.length=0};var k=()=>{g($);{g(b);if(w=$.length>0){p.raf(k)}}};var j=e=>h().then(e);var E=S(b,true);var C=e=>{e=typeof e;return e==="object"||e==="function"};function M(e){var t,n,r;return(r=(n=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:n.getAttribute("content"))!=null?r:void 0}var O=e=>e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");var x={};r(x,{err:()=>P,map:()=>R,ok:()=>U,unwrap:()=>W,unwrapErr:()=>D});var U=e=>({isOk:true,isErr:false,value:e});var P=e=>({isOk:false,isErr:true,value:e});function R(e,t){if(e.isOk){const n=t(e.value);if(n instanceof Promise){return n.then((e=>U(e)))}else{return U(n)}}if(e.isErr){const t=e.value;return P(t)}throw"should never get here"}var W=e=>{if(e.isOk){return e.value}else{throw e.value}};var D=e=>{if(e.isErr){return e.value}else{throw e.value}};function A(e){return void 0}var L;function N(e){var t;const n=this.attachShadow({mode:"open"});if(L===void 0)L=(t=A())!=null?t:null;if(L){if(y){n.adoptedStyleSheets.push(L)}else{n.adoptedStyleSheets=[...n.adoptedStyleSheets,L]}}}var T=(e,t="")=>{{return()=>{}}};var q=(e,t)=>{{return()=>{}}};var z=new WeakMap;var F=(e,t,n)=>{let r=f.get(e);if(m&&n){r=r||new CSSStyleSheet;if(typeof r==="string"){r=t}else{r.replaceSync(t)}}else{r=t}f.set(e,r)};var H=(e,t,n)=>{var r;const o=V(t);const s=f.get(o);if(!d.document){return o}e=e.nodeType===11?e:d.document;if(s){if(typeof s==="string"){e=e.head||e;let n=z.get(e);let i;if(!n){z.set(e,n=new Set)}if(!n.has(o)){{i=d.document.createElement("style");i.innerHTML=s;const n=(r=p.$)!=null?r:M(d.document);if(n!=null){i.setAttribute("nonce",n)}if(!(t.o&1)){if(e.nodeName==="HEAD"){const t=e.querySelectorAll("link[rel=preconnect]");const n=t.length>0?t[t.length-1].nextSibling:e.querySelector("style");e.insertBefore(i,(n==null?void 0:n.parentNode)===e?n:null)}else if("host"in e){if(m){const t=new CSSStyleSheet;t.replaceSync(s);if(y){e.adoptedStyleSheets.unshift(t)}else{e.adoptedStyleSheets=[t,...e.adoptedStyleSheets]}}else{const t=e.querySelector("style");if(t){t.innerHTML=s+t.innerHTML}else{e.prepend(i)}}}else{e.append(i)}}if(t.o&1){e.insertBefore(i,null)}}if(t.o&4){i.innerHTML+=v}if(n){n.add(o)}}}else if(!e.adoptedStyleSheets.includes(s)){if(y){e.adoptedStyleSheets.push(s)}else{e.adoptedStyleSheets=[...e.adoptedStyleSheets,s]}}}return o};var I=e=>{const t=e.i;const n=e.$hostElement$;const r=t.o;const o=T("attachStyles",t.p);const s=H(n.shadowRoot?n.shadowRoot:n.getRootNode(),t);if(r&10){n["s-sc"]=s;n.classList.add(s+"-h")}o()};var V=(e,t)=>"sc-"+e.p;var Y=(e,t,...n)=>{let r=null;let o=null;let s=false;let i=false;const l=[];const a=t=>{for(let n=0;n<t.length;n++){r=t[n];if(Array.isArray(r)){a(r)}else if(r!=null&&typeof r!=="boolean"){if(s=typeof e!=="function"&&!C(r)){r=String(r)}if(s&&i){l[l.length-1].S+=r}else{l.push(s?_(null,r):r)}i=s}}};a(n);if(t){if(t.key){o=t.key}{const e=t.className||t.class;if(e){t.class=typeof e!=="object"?e:Object.keys(e).filter((t=>e[t])).join(" ")}}}const c=_(e,null);c.k=t;if(l.length>0){c.j=l}{c.C=o}return c};var _=(e,t)=>{const n={o:0,M:e,S:t,O:null,j:null};{n.k=null}{n.C=null}return n};var B={};var G=e=>e&&e.M===B;var J=e=>{const t=O(e);return new RegExp(`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${t}))(${t}\\b)`,"g")};J("::slotted");J(":host");J(":host-context");var K=(e,t,n)=>{const r=p.ce(t,n);e.dispatchEvent(r);return r};var Q=(e,t,n,r,o,s,i)=>{if(n===r){return}t.toLowerCase();if(t==="class"){const t=e.classList;const o=Z(n);let s=Z(r);{t.remove(...o.filter((e=>e&&!s.includes(e))));t.add(...s.filter((e=>e&&!o.includes(e))))}}};var X=/\s/;var Z=e=>{if(typeof e==="object"&&e&&"baseVal"in e){e=e.baseVal}if(!e||typeof e!=="string"){return[]}return e.split(X)};var ee=(e,t,n,r)=>{const o=t.O.nodeType===11&&t.O.host?t.O.host:t.O;const s=e&&e.k||{};const i=t.k||{};for(const e of te(Object.keys(i))){Q(o,e,s[e],i[e])}};function te(e){return e.includes("ref")?[...e.filter((e=>e!=="ref")),"ref"]:e}var ne;var re=(e,t,n)=>{const r=t.j[n];let o=0;let s;let i;if(r.S!==null){s=r.O=d.document.createTextNode(r.S)}else{if(!d.document){throw new Error("You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.")}s=r.O=d.document.createElement(r.M);{ee(null,r)}if(r.j){for(o=0;o<r.j.length;++o){i=re(e,r,o);if(i){s.appendChild(i)}}}}s["s-hn"]=ne;return s};var oe=(e,t,n,r,o,s)=>{let i=e;let l;if(i.shadowRoot&&i.tagName===ne){i=i.shadowRoot}for(;o<=s;++o){if(r[o]){l=re(null,n,o);if(l){r[o].O=l;ie(i,l,t)}}}};var se=(e,t,n=false)=>{const r=t.O=e.O;const o=t.j;const s=t.S;if(s===null){{ee(e,t)}if(o!==null){oe(r,null,t,o,0,o.length-1)}else;}else if(e.S!==s){r.data=s}};var ie=(e,t,n)=>{{return e==null?void 0:e.insertBefore(t,n)}};var le=(e,t,n=false)=>{const r=e.$hostElement$;const o=e.U||_(null,null);const s=G(t);const i=s?t:Y(null,null,t);ne=r.tagName;if(n&&i.k){for(const e of Object.keys(i.k)){if(r.hasAttribute(e)&&!["key","ref","style","class"].includes(e)){i.k[e]=r[e]}}}i.M=null;i.o|=4;e.U=i;i.O=o.O=r.shadowRoot||r;se(o,i,n)};var ae=(e,t)=>{if(t&&!e.P&&t["s-p"]){const n=t["s-p"].push(new Promise((r=>e.P=()=>{t["s-p"].splice(n-1,1);r()})))}};var ce=(e,t)=>{if(e.o&4){e.o|=512;return}ae(e,e.R);const n=()=>fe(e,t);if(t){queueMicrotask((()=>{n()}));return}return E(n)};var fe=(e,t)=>{const n=e.$hostElement$;const r=T("scheduleUpdate",e.i.p);const o=e.t;if(!o){throw new Error(`Can't render component <${n.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`)}let s;if(t){s=ye(o,"componentWillLoad",void 0,n)}else{s=ye(o,"componentWillUpdate",void 0,n)}s=ue(s,(()=>ye(o,"componentWillRender",void 0,n)));r();return ue(s,(()=>de(e,o,t)))};var ue=(e,t)=>ve(e)?e.then(t).catch((e=>{console.error(e);t()})):t();var ve=e=>e instanceof Promise||e&&e.then&&typeof e.then==="function";var de=async(e,t,n)=>{var r;const o=e.$hostElement$;const s=T("update",e.i.p);const i=o["s-rc"];if(n){I(e)}const l=T("render",e.i.p);{pe(e,t,o,n)}if(i){i.map((e=>e()));o["s-rc"]=void 0}l();s();{const t=(r=o["s-p"])!=null?r:[];const n=()=>he(e);if(t.length===0){n()}else{Promise.all(t).then(n);e.o|=4;t.length=0}}};var pe=(e,t,n,r)=>{try{t=t.render();{e.o|=2}{{{le(e,t,r)}}}}catch(t){l(t,e.$hostElement$)}return null};var he=e=>{const t=e.i.p;const n=e.$hostElement$;const r=T("postUpdate",t);const o=e.t;const s=e.R;ye(o,"componentDidRender",void 0,n);if(!(e.o&64)){e.o|=64;{we(n)}ye(o,"componentDidLoad",void 0,n);r();{e.v(n);if(!s){me()}}}else{ye(o,"componentDidUpdate",void 0,n);r()}{if(e.P){e.P();e.P=void 0}if(e.o&512){j((()=>ce(e,false)))}e.o&=-517}};var me=t=>{j((()=>K(d,"appload",{detail:{namespace:e}})))};var ye=(e,t,n,r)=>{if(e&&e[t]){try{return e[t](n)}catch(e){l(e,r)}}return void 0};var we=e=>{var n;return e.classList.add((n=t.hydratedSelectorName)!=null?n:"hydrated")};var $e=(e,t,n)=>e;var be=async(e,t,n,r)=>{let o;if((t.o&32)===0){t.o|=32;const r=n.h;if(r){const r=c(n,t);if(r&&"then"in r){const e=q();o=await r;e()}else{o=r}if(!o){throw new Error(`Constructor for "${n.p}#${t.W}" was not found`)}const s=T("createInstance",n.p);try{new o(t)}catch(t){l(t,e)}s();Se(t.t,e)}else{o=e.constructor;const n=e.localName;customElements.whenDefined(n).then((()=>t.o|=128))}if(o&&o.style){let e;if(typeof o.style==="string"){e=o.style}const t=V(n);if(!f.has(t)){const r=T("registerStyles",n.p);F(t,e,!!(n.o&1));r()}}}const s=t.R;const i=()=>ce(t,true);if(s&&s["s-rc"]){s["s-rc"].push(i)}else{i()}};var Se=(e,t)=>{{ye(e,"connectedCallback",void 0,t)}};var ge=e=>{if((p.o&1)===0){const t=o(e);if(!t){return}const n=t.i;const r=T("connectedCallback",n.p);if(!(t.o&1)){t.o|=1;{let n=e;while(n=n.parentNode||n.host){if(n["s-p"]){ae(t,t.R=n);break}}}{be(e,t,n)}}else{if(t==null?void 0:t.t){Se(t.t,e)}else if(t==null?void 0:t.u){t.u.then((()=>Se(t.t,e)))}}r()}};var ke=(e,t)=>{{ye(e,"disconnectedCallback",void 0,t||e)}};var je=async e=>{if((p.o&1)===0){const t=o(e);if(t==null?void 0:t.t){ke(t.t,e)}else if(t==null?void 0:t.u){t.u.then((()=>ke(t.t,e)))}}if(z.has(e)){z.delete(e)}if(e.shadowRoot&&z.has(e.shadowRoot)){z.delete(e.shadowRoot)}};var Ee=(e,t={})=>{var n;if(!d.document){console.warn("Stencil: No document found. Skipping bootstrapping lazy components.");return}const r=T();const s=[];const l=t.exclude||[];const a=d.customElements;const c=d.document.head;const f=c.querySelector("meta[charset]");const h=d.document.createElement("style");const m=[];let y;let w=true;Object.assign(p,t);p.m=new URL(t.resourcesUrl||"./",d.document.baseURI).href;let $=false;e.map((e=>{e[1].map((t=>{const n={o:t[0],p:t[1],D:t[2],A:t[3]};if(n.o&4){$=true}const r=n.p;const c=class extends HTMLElement{constructor(e){super(e);this.hasRegisteredEventListeners=false;e=this;i(e,n);if(n.o&1){{if(!e.shadowRoot){N.call(e,n)}else{if(e.shadowRoot.mode!=="open"){throw new Error(`Unable to re-use existing shadow root for ${n.p}! Mode is set to ${e.shadowRoot.mode} but Stencil only supports open shadow roots.`)}}}}}connectedCallback(){const e=o(this);if(!e){return}if(!this.hasRegisteredEventListeners){this.hasRegisteredEventListeners=true}if(y){clearTimeout(y);y=null}if(w){m.push(this)}else{p.jmp((()=>ge(this)))}}disconnectedCallback(){p.jmp((()=>je(this)));p.raf((()=>{var e;const t=o(this);if(!t){return}const n=m.findIndex((e=>e===this));if(n>-1){m.splice(n,1)}if(((e=t==null?void 0:t.U)==null?void 0:e.O)instanceof Node&&!t.U.O.isConnected){delete t.U.O}}))}componentOnReady(){var e;return(e=o(this))==null?void 0:e.u}};n.h=e[0];if(!l.includes(r)&&!a.get(r)){s.push(r);a.define(r,$e(c))}}))}));if(s.length>0){if($){h.textContent+=v}{h.textContent+=s.sort()+u}if(h.innerHTML.length){h.setAttribute("data-styles","");const e=(n=p.$)!=null?n:M(d.document);if(e!=null){h.setAttribute("nonce",e)}c.insertBefore(h,f?f.nextSibling:c.firstChild)}}w=false;if(m.length){m.map((e=>e.connectedCallback()))}else{{p.jmp((()=>y=setTimeout(me,30)))}}r()};var Ce=e=>p.$=e;export{Ee as b,Y as h,h as p,s as r,Ce as s};